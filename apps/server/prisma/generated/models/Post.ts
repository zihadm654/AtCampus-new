/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `Post` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Post
 *
 */
export type PostModel =
	runtime.Types.Result.DefaultSelection<Prisma.$PostPayload>;

export type AggregatePost = {
	_count: PostCountAggregateOutputType | null;
	_min: PostMinAggregateOutputType | null;
	_max: PostMaxAggregateOutputType | null;
};

export type PostMinAggregateOutputType = {
	id: string | null;
	content: string | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	userId: string | null;
};

export type PostMaxAggregateOutputType = {
	id: string | null;
	content: string | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	userId: string | null;
};

export type PostCountAggregateOutputType = {
	id: number;
	content: number;
	createdAt: number;
	updatedAt: number;
	userId: number;
	_all: number;
};

export type PostMinAggregateInputType = {
	id?: true;
	content?: true;
	createdAt?: true;
	updatedAt?: true;
	userId?: true;
};

export type PostMaxAggregateInputType = {
	id?: true;
	content?: true;
	createdAt?: true;
	updatedAt?: true;
	userId?: true;
};

export type PostCountAggregateInputType = {
	id?: true;
	content?: true;
	createdAt?: true;
	updatedAt?: true;
	userId?: true;
	_all?: true;
};

export type PostAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Post to aggregate.
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Posts to fetch.
	 */
	orderBy?:
		| Prisma.PostOrderByWithRelationInput
		| Prisma.PostOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.PostWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Posts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Posts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Posts
	 **/
	_count?: true | PostCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: PostMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: PostMaxAggregateInputType;
};

export type GetPostAggregateType<T extends PostAggregateArgs> = {
	[P in keyof T & keyof AggregatePost]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregatePost[P]>
		: Prisma.GetScalarType<T[P], AggregatePost[P]>;
};

export type PostGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.PostWhereInput;
	orderBy?:
		| Prisma.PostOrderByWithAggregationInput
		| Prisma.PostOrderByWithAggregationInput[];
	by: Prisma.PostScalarFieldEnum[] | Prisma.PostScalarFieldEnum;
	having?: Prisma.PostScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: PostCountAggregateInputType | true;
	_min?: PostMinAggregateInputType;
	_max?: PostMaxAggregateInputType;
};

export type PostGroupByOutputType = {
	id: string;
	content: string;
	createdAt: Date;
	updatedAt: Date;
	userId: string;
	_count: PostCountAggregateOutputType | null;
	_min: PostMinAggregateOutputType | null;
	_max: PostMaxAggregateOutputType | null;
};

type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<PostGroupByOutputType, T["by"]> & {
			[P in keyof T & keyof PostGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], PostGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], PostGroupByOutputType[P]>;
		}
	>
>;

export type PostWhereInput = {
	AND?: Prisma.PostWhereInput | Prisma.PostWhereInput[];
	OR?: Prisma.PostWhereInput[];
	NOT?: Prisma.PostWhereInput | Prisma.PostWhereInput[];
	id?: Prisma.StringFilter<"Post"> | string;
	content?: Prisma.StringFilter<"Post"> | string;
	createdAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
	userId?: Prisma.StringFilter<"Post"> | string;
	user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
	comments?: Prisma.CommentListRelationFilter;
	likes?: Prisma.LikeListRelationFilter;
	linkedNotifications?: Prisma.NotificationListRelationFilter;
	attachments?: Prisma.MediaListRelationFilter;
	bookmarks?: Prisma.BookmarkListRelationFilter;
	views?: Prisma.ContentViewListRelationFilter;
};

export type PostOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	user?: Prisma.UserOrderByWithRelationInput;
	comments?: Prisma.CommentOrderByRelationAggregateInput;
	likes?: Prisma.LikeOrderByRelationAggregateInput;
	linkedNotifications?: Prisma.NotificationOrderByRelationAggregateInput;
	attachments?: Prisma.MediaOrderByRelationAggregateInput;
	bookmarks?: Prisma.BookmarkOrderByRelationAggregateInput;
	views?: Prisma.ContentViewOrderByRelationAggregateInput;
};

export type PostWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		AND?: Prisma.PostWhereInput | Prisma.PostWhereInput[];
		OR?: Prisma.PostWhereInput[];
		NOT?: Prisma.PostWhereInput | Prisma.PostWhereInput[];
		content?: Prisma.StringFilter<"Post"> | string;
		createdAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
		userId?: Prisma.StringFilter<"Post"> | string;
		user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
		comments?: Prisma.CommentListRelationFilter;
		likes?: Prisma.LikeListRelationFilter;
		linkedNotifications?: Prisma.NotificationListRelationFilter;
		attachments?: Prisma.MediaListRelationFilter;
		bookmarks?: Prisma.BookmarkListRelationFilter;
		views?: Prisma.ContentViewListRelationFilter;
	},
	"id"
>;

export type PostOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	_count?: Prisma.PostCountOrderByAggregateInput;
	_max?: Prisma.PostMaxOrderByAggregateInput;
	_min?: Prisma.PostMinOrderByAggregateInput;
};

export type PostScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.PostScalarWhereWithAggregatesInput
		| Prisma.PostScalarWhereWithAggregatesInput[];
	OR?: Prisma.PostScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.PostScalarWhereWithAggregatesInput
		| Prisma.PostScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Post"> | string;
	content?: Prisma.StringWithAggregatesFilter<"Post"> | string;
	createdAt?: Prisma.DateTimeWithAggregatesFilter<"Post"> | Date | string;
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Post"> | Date | string;
	userId?: Prisma.StringWithAggregatesFilter<"Post"> | string;
};

export type PostCreateInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostUpdateInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateManyInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
};

export type PostUpdateManyMutationInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PostUncheckedUpdateManyInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type PostListRelationFilter = {
	every?: Prisma.PostWhereInput;
	some?: Prisma.PostWhereInput;
	none?: Prisma.PostWhereInput;
};

export type PostOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type PostCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
};

export type PostMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
};

export type PostMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
};

export type PostScalarRelationFilter = {
	is?: Prisma.PostWhereInput;
	isNot?: Prisma.PostWhereInput;
};

export type PostNullableScalarRelationFilter = {
	is?: Prisma.PostWhereInput | null;
	isNot?: Prisma.PostWhereInput | null;
};

export type PostCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.PostCreateWithoutUserInput,
				Prisma.PostUncheckedCreateWithoutUserInput
		  >
		| Prisma.PostCreateWithoutUserInput[]
		| Prisma.PostUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.PostCreateOrConnectWithoutUserInput
		| Prisma.PostCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.PostCreateManyUserInputEnvelope;
	connect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
};

export type PostUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.PostCreateWithoutUserInput,
				Prisma.PostUncheckedCreateWithoutUserInput
		  >
		| Prisma.PostCreateWithoutUserInput[]
		| Prisma.PostUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.PostCreateOrConnectWithoutUserInput
		| Prisma.PostCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.PostCreateManyUserInputEnvelope;
	connect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
};

export type PostUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PostCreateWithoutUserInput,
				Prisma.PostUncheckedCreateWithoutUserInput
		  >
		| Prisma.PostCreateWithoutUserInput[]
		| Prisma.PostUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.PostCreateOrConnectWithoutUserInput
		| Prisma.PostCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.PostUpsertWithWhereUniqueWithoutUserInput
		| Prisma.PostUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.PostCreateManyUserInputEnvelope;
	set?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	disconnect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	delete?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	connect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	update?:
		| Prisma.PostUpdateWithWhereUniqueWithoutUserInput
		| Prisma.PostUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.PostUpdateManyWithWhereWithoutUserInput
		| Prisma.PostUpdateManyWithWhereWithoutUserInput[];
	deleteMany?: Prisma.PostScalarWhereInput | Prisma.PostScalarWhereInput[];
};

export type PostUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PostCreateWithoutUserInput,
				Prisma.PostUncheckedCreateWithoutUserInput
		  >
		| Prisma.PostCreateWithoutUserInput[]
		| Prisma.PostUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.PostCreateOrConnectWithoutUserInput
		| Prisma.PostCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.PostUpsertWithWhereUniqueWithoutUserInput
		| Prisma.PostUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.PostCreateManyUserInputEnvelope;
	set?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	disconnect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	delete?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	connect?: Prisma.PostWhereUniqueInput | Prisma.PostWhereUniqueInput[];
	update?:
		| Prisma.PostUpdateWithWhereUniqueWithoutUserInput
		| Prisma.PostUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.PostUpdateManyWithWhereWithoutUserInput
		| Prisma.PostUpdateManyWithWhereWithoutUserInput[];
	deleteMany?: Prisma.PostScalarWhereInput | Prisma.PostScalarWhereInput[];
};

export type PostCreateNestedOneWithoutBookmarksInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutBookmarksInput,
		Prisma.PostUncheckedCreateWithoutBookmarksInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutBookmarksInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneRequiredWithoutBookmarksNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutBookmarksInput,
		Prisma.PostUncheckedCreateWithoutBookmarksInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutBookmarksInput;
	upsert?: Prisma.PostUpsertWithoutBookmarksInput;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutBookmarksInput,
			Prisma.PostUpdateWithoutBookmarksInput
		>,
		Prisma.PostUncheckedUpdateWithoutBookmarksInput
	>;
};

export type PostCreateNestedOneWithoutAttachmentsInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutAttachmentsInput,
		Prisma.PostUncheckedCreateWithoutAttachmentsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutAttachmentsInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneWithoutAttachmentsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutAttachmentsInput,
		Prisma.PostUncheckedCreateWithoutAttachmentsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutAttachmentsInput;
	upsert?: Prisma.PostUpsertWithoutAttachmentsInput;
	disconnect?: boolean;
	delete?: Prisma.PostWhereInput | boolean;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutAttachmentsInput,
			Prisma.PostUpdateWithoutAttachmentsInput
		>,
		Prisma.PostUncheckedUpdateWithoutAttachmentsInput
	>;
};

export type PostCreateNestedOneWithoutCommentsInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutCommentsInput,
		Prisma.PostUncheckedCreateWithoutCommentsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutCommentsInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneWithoutCommentsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutCommentsInput,
		Prisma.PostUncheckedCreateWithoutCommentsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutCommentsInput;
	upsert?: Prisma.PostUpsertWithoutCommentsInput;
	disconnect?: boolean;
	delete?: Prisma.PostWhereInput | boolean;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutCommentsInput,
			Prisma.PostUpdateWithoutCommentsInput
		>,
		Prisma.PostUncheckedUpdateWithoutCommentsInput
	>;
};

export type PostCreateNestedOneWithoutLikesInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutLikesInput,
		Prisma.PostUncheckedCreateWithoutLikesInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutLikesInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneWithoutLikesNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutLikesInput,
		Prisma.PostUncheckedCreateWithoutLikesInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutLikesInput;
	upsert?: Prisma.PostUpsertWithoutLikesInput;
	disconnect?: boolean;
	delete?: Prisma.PostWhereInput | boolean;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutLikesInput,
			Prisma.PostUpdateWithoutLikesInput
		>,
		Prisma.PostUncheckedUpdateWithoutLikesInput
	>;
};

export type PostCreateNestedOneWithoutLinkedNotificationsInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedCreateWithoutLinkedNotificationsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutLinkedNotificationsInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneWithoutLinkedNotificationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedCreateWithoutLinkedNotificationsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutLinkedNotificationsInput;
	upsert?: Prisma.PostUpsertWithoutLinkedNotificationsInput;
	disconnect?: boolean;
	delete?: Prisma.PostWhereInput | boolean;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutLinkedNotificationsInput,
			Prisma.PostUpdateWithoutLinkedNotificationsInput
		>,
		Prisma.PostUncheckedUpdateWithoutLinkedNotificationsInput
	>;
};

export type PostCreateNestedOneWithoutViewsInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutViewsInput,
		Prisma.PostUncheckedCreateWithoutViewsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutViewsInput;
	connect?: Prisma.PostWhereUniqueInput;
};

export type PostUpdateOneWithoutViewsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PostCreateWithoutViewsInput,
		Prisma.PostUncheckedCreateWithoutViewsInput
	>;
	connectOrCreate?: Prisma.PostCreateOrConnectWithoutViewsInput;
	upsert?: Prisma.PostUpsertWithoutViewsInput;
	disconnect?: boolean;
	delete?: Prisma.PostWhereInput | boolean;
	connect?: Prisma.PostWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PostUpdateToOneWithWhereWithoutViewsInput,
			Prisma.PostUpdateWithoutViewsInput
		>,
		Prisma.PostUncheckedUpdateWithoutViewsInput
	>;
};

export type PostCreateWithoutUserInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutUserInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutUserInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutUserInput,
		Prisma.PostUncheckedCreateWithoutUserInput
	>;
};

export type PostCreateManyUserInputEnvelope = {
	data: Prisma.PostCreateManyUserInput | Prisma.PostCreateManyUserInput[];
};

export type PostUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.PostWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutUserInput,
		Prisma.PostUncheckedUpdateWithoutUserInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutUserInput,
		Prisma.PostUncheckedCreateWithoutUserInput
	>;
};

export type PostUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.PostWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutUserInput,
		Prisma.PostUncheckedUpdateWithoutUserInput
	>;
};

export type PostUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.PostScalarWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateManyMutationInput,
		Prisma.PostUncheckedUpdateManyWithoutUserInput
	>;
};

export type PostScalarWhereInput = {
	AND?: Prisma.PostScalarWhereInput | Prisma.PostScalarWhereInput[];
	OR?: Prisma.PostScalarWhereInput[];
	NOT?: Prisma.PostScalarWhereInput | Prisma.PostScalarWhereInput[];
	id?: Prisma.StringFilter<"Post"> | string;
	content?: Prisma.StringFilter<"Post"> | string;
	createdAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"Post"> | Date | string;
	userId?: Prisma.StringFilter<"Post"> | string;
};

export type PostCreateWithoutBookmarksInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutBookmarksInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutBookmarksInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutBookmarksInput,
		Prisma.PostUncheckedCreateWithoutBookmarksInput
	>;
};

export type PostUpsertWithoutBookmarksInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutBookmarksInput,
		Prisma.PostUncheckedUpdateWithoutBookmarksInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutBookmarksInput,
		Prisma.PostUncheckedCreateWithoutBookmarksInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutBookmarksInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutBookmarksInput,
		Prisma.PostUncheckedUpdateWithoutBookmarksInput
	>;
};

export type PostUpdateWithoutBookmarksInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutBookmarksInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateWithoutAttachmentsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutAttachmentsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutAttachmentsInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutAttachmentsInput,
		Prisma.PostUncheckedCreateWithoutAttachmentsInput
	>;
};

export type PostUpsertWithoutAttachmentsInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutAttachmentsInput,
		Prisma.PostUncheckedUpdateWithoutAttachmentsInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutAttachmentsInput,
		Prisma.PostUncheckedCreateWithoutAttachmentsInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutAttachmentsInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutAttachmentsInput,
		Prisma.PostUncheckedUpdateWithoutAttachmentsInput
	>;
};

export type PostUpdateWithoutAttachmentsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutAttachmentsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateWithoutCommentsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutCommentsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutCommentsInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutCommentsInput,
		Prisma.PostUncheckedCreateWithoutCommentsInput
	>;
};

export type PostUpsertWithoutCommentsInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutCommentsInput,
		Prisma.PostUncheckedUpdateWithoutCommentsInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutCommentsInput,
		Prisma.PostUncheckedCreateWithoutCommentsInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutCommentsInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutCommentsInput,
		Prisma.PostUncheckedUpdateWithoutCommentsInput
	>;
};

export type PostUpdateWithoutCommentsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutCommentsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateWithoutLikesInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutLikesInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutLikesInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutLikesInput,
		Prisma.PostUncheckedCreateWithoutLikesInput
	>;
};

export type PostUpsertWithoutLikesInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutLikesInput,
		Prisma.PostUncheckedUpdateWithoutLikesInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutLikesInput,
		Prisma.PostUncheckedCreateWithoutLikesInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutLikesInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutLikesInput,
		Prisma.PostUncheckedUpdateWithoutLikesInput
	>;
};

export type PostUpdateWithoutLikesInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutLikesInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateWithoutLinkedNotificationsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutLinkedNotificationsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
	views?: Prisma.ContentViewUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutLinkedNotificationsInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedCreateWithoutLinkedNotificationsInput
	>;
};

export type PostUpsertWithoutLinkedNotificationsInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedUpdateWithoutLinkedNotificationsInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedCreateWithoutLinkedNotificationsInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutLinkedNotificationsInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutLinkedNotificationsInput,
		Prisma.PostUncheckedUpdateWithoutLinkedNotificationsInput
	>;
};

export type PostUpdateWithoutLinkedNotificationsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutLinkedNotificationsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateWithoutViewsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutPostsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkCreateNestedManyWithoutPostInput;
};

export type PostUncheckedCreateWithoutViewsInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	userId: string;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPostInput;
	likes?: Prisma.LikeUncheckedCreateNestedManyWithoutPostInput;
	linkedNotifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutPostInput;
	attachments?: Prisma.MediaUncheckedCreateNestedManyWithoutPostInput;
	bookmarks?: Prisma.BookmarkUncheckedCreateNestedManyWithoutPostInput;
};

export type PostCreateOrConnectWithoutViewsInput = {
	where: Prisma.PostWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutViewsInput,
		Prisma.PostUncheckedCreateWithoutViewsInput
	>;
};

export type PostUpsertWithoutViewsInput = {
	update: Prisma.XOR<
		Prisma.PostUpdateWithoutViewsInput,
		Prisma.PostUncheckedUpdateWithoutViewsInput
	>;
	create: Prisma.XOR<
		Prisma.PostCreateWithoutViewsInput,
		Prisma.PostUncheckedCreateWithoutViewsInput
	>;
	where?: Prisma.PostWhereInput;
};

export type PostUpdateToOneWithWhereWithoutViewsInput = {
	where?: Prisma.PostWhereInput;
	data: Prisma.XOR<
		Prisma.PostUpdateWithoutViewsInput,
		Prisma.PostUncheckedUpdateWithoutViewsInput
	>;
};

export type PostUpdateWithoutViewsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutPostsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutViewsInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostCreateManyUserInput = {
	id?: string;
	content: string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type PostUpdateWithoutUserInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	comments?: Prisma.CommentUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateWithoutUserInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPostNestedInput;
	likes?: Prisma.LikeUncheckedUpdateManyWithoutPostNestedInput;
	linkedNotifications?: Prisma.NotificationUncheckedUpdateManyWithoutPostNestedInput;
	attachments?: Prisma.MediaUncheckedUpdateManyWithoutPostNestedInput;
	bookmarks?: Prisma.BookmarkUncheckedUpdateManyWithoutPostNestedInput;
	views?: Prisma.ContentViewUncheckedUpdateManyWithoutPostNestedInput;
};

export type PostUncheckedUpdateManyWithoutUserInput = {
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type PostCountOutputType
 */

export type PostCountOutputType = {
	comments: number;
	likes: number;
	linkedNotifications: number;
	attachments: number;
	bookmarks: number;
	views: number;
};

export type PostCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	comments?: boolean | PostCountOutputTypeCountCommentsArgs;
	likes?: boolean | PostCountOutputTypeCountLikesArgs;
	linkedNotifications?:
		| boolean
		| PostCountOutputTypeCountLinkedNotificationsArgs;
	attachments?: boolean | PostCountOutputTypeCountAttachmentsArgs;
	bookmarks?: boolean | PostCountOutputTypeCountBookmarksArgs;
	views?: boolean | PostCountOutputTypeCountViewsArgs;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the PostCountOutputType
	 */
	select?: Prisma.PostCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountCommentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CommentWhereInput;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountLikesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.LikeWhereInput;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountLinkedNotificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.NotificationWhereInput;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountAttachmentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.MediaWhereInput;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountBookmarksArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.BookmarkWhereInput;
};

/**
 * PostCountOutputType without action
 */
export type PostCountOutputTypeCountViewsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ContentViewWhereInput;
};

export type PostSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		content?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		userId?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		comments?: boolean | Prisma.Post$commentsArgs<ExtArgs>;
		likes?: boolean | Prisma.Post$likesArgs<ExtArgs>;
		linkedNotifications?:
			| boolean
			| Prisma.Post$linkedNotificationsArgs<ExtArgs>;
		attachments?: boolean | Prisma.Post$attachmentsArgs<ExtArgs>;
		bookmarks?: boolean | Prisma.Post$bookmarksArgs<ExtArgs>;
		views?: boolean | Prisma.Post$viewsArgs<ExtArgs>;
		_count?: boolean | Prisma.PostCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["post"]
>;

export type PostSelectScalar = {
	id?: boolean;
	content?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
	userId?: boolean;
};

export type PostOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	"id" | "content" | "createdAt" | "updatedAt" | "userId",
	ExtArgs["result"]["post"]
>;
export type PostInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	comments?: boolean | Prisma.Post$commentsArgs<ExtArgs>;
	likes?: boolean | Prisma.Post$likesArgs<ExtArgs>;
	linkedNotifications?: boolean | Prisma.Post$linkedNotificationsArgs<ExtArgs>;
	attachments?: boolean | Prisma.Post$attachmentsArgs<ExtArgs>;
	bookmarks?: boolean | Prisma.Post$bookmarksArgs<ExtArgs>;
	views?: boolean | Prisma.Post$viewsArgs<ExtArgs>;
	_count?: boolean | Prisma.PostCountOutputTypeDefaultArgs<ExtArgs>;
};

export type $PostPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Post";
	objects: {
		user: Prisma.$UserPayload<ExtArgs>;
		comments: Prisma.$CommentPayload<ExtArgs>[];
		likes: Prisma.$LikePayload<ExtArgs>[];
		linkedNotifications: Prisma.$NotificationPayload<ExtArgs>[];
		attachments: Prisma.$MediaPayload<ExtArgs>[];
		bookmarks: Prisma.$BookmarkPayload<ExtArgs>[];
		views: Prisma.$ContentViewPayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			content: string;
			createdAt: Date;
			updatedAt: Date;
			userId: string;
		},
		ExtArgs["result"]["post"]
	>;
	composites: {};
};

export type PostGetPayload<
	S extends boolean | null | undefined | PostDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$PostPayload, S>;

export type PostCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<PostFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: PostCountAggregateInputType | true;
};

export interface PostDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Post"];
		meta: { name: "Post" };
	};
	/**
	 * Find zero or one Post that matches the filter.
	 * @param {PostFindUniqueArgs} args - Arguments to find a Post
	 * @example
	 * // Get one Post
	 * const post = await prisma.post.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends PostFindUniqueArgs>(
		args: Prisma.SelectSubset<T, PostFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Post that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
	 * @example
	 * // Get one Post
	 * const post = await prisma.post.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Post that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostFindFirstArgs} args - Arguments to find a Post
	 * @example
	 * // Get one Post
	 * const post = await prisma.post.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends PostFindFirstArgs>(
		args?: Prisma.SelectSubset<T, PostFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Post that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
	 * @example
	 * // Get one Post
	 * const post = await prisma.post.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Posts that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Posts
	 * const posts = await prisma.post.findMany()
	 *
	 * // Get first 10 Posts
	 * const posts = await prisma.post.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends PostFindManyArgs>(
		args?: Prisma.SelectSubset<T, PostFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Post.
	 * @param {PostCreateArgs} args - Arguments to create a Post.
	 * @example
	 * // Create one Post
	 * const Post = await prisma.post.create({
	 *   data: {
	 *     // ... data to create a Post
	 *   }
	 * })
	 *
	 */
	create<T extends PostCreateArgs>(
		args: Prisma.SelectSubset<T, PostCreateArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Posts.
	 * @param {PostCreateManyArgs} args - Arguments to create many Posts.
	 * @example
	 * // Create many Posts
	 * const post = await prisma.post.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends PostCreateManyArgs>(
		args?: Prisma.SelectSubset<T, PostCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Delete a Post.
	 * @param {PostDeleteArgs} args - Arguments to delete one Post.
	 * @example
	 * // Delete one Post
	 * const Post = await prisma.post.delete({
	 *   where: {
	 *     // ... filter to delete one Post
	 *   }
	 * })
	 *
	 */
	delete<T extends PostDeleteArgs>(
		args: Prisma.SelectSubset<T, PostDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Post.
	 * @param {PostUpdateArgs} args - Arguments to update one Post.
	 * @example
	 * // Update one Post
	 * const post = await prisma.post.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends PostUpdateArgs>(
		args: Prisma.SelectSubset<T, PostUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Posts.
	 * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
	 * @example
	 * // Delete a few Posts
	 * const { count } = await prisma.post.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends PostDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, PostDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Posts.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Posts
	 * const post = await prisma.post.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends PostUpdateManyArgs>(
		args: Prisma.SelectSubset<T, PostUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create or update one Post.
	 * @param {PostUpsertArgs} args - Arguments to update or create a Post.
	 * @example
	 * // Update or create a Post
	 * const post = await prisma.post.upsert({
	 *   create: {
	 *     // ... data to create a Post
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Post we want to update
	 *   }
	 * })
	 */
	upsert<T extends PostUpsertArgs>(
		args: Prisma.SelectSubset<T, PostUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__PostClient<
		runtime.Types.Result.GetResult<
			Prisma.$PostPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Posts that matches the filter.
	 * @param {PostFindRawArgs} args - Select which filters you would like to apply.
	 * @example
	 * const post = await prisma.post.findRaw({
	 *   filter: { age: { $gt: 25 } }
	 * })
	 */
	findRaw(
		args?: Prisma.PostFindRawArgs,
	): Prisma.PrismaPromise<Prisma.JsonObject>;

	/**
	 * Perform aggregation operations on a Post.
	 * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
	 * @example
	 * const post = await prisma.post.aggregateRaw({
	 *   pipeline: [
	 *     { $match: { status: "registered" } },
	 *     { $group: { _id: "$country", total: { $sum: 1 } } }
	 *   ]
	 * })
	 */
	aggregateRaw(
		args?: Prisma.PostAggregateRawArgs,
	): Prisma.PrismaPromise<Prisma.JsonObject>;

	/**
	 * Count the number of Posts.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostCountArgs} args - Arguments to filter Posts to count.
	 * @example
	 * // Count the number of Posts
	 * const count = await prisma.post.count({
	 *   where: {
	 *     // ... the filter for the Posts we want to count
	 *   }
	 * })
	 **/
	count<T extends PostCountArgs>(
		args?: Prisma.Subset<T, PostCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], PostCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Post.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends PostAggregateArgs>(
		args: Prisma.Subset<T, PostAggregateArgs>,
	): Prisma.PrismaPromise<GetPostAggregateType<T>>;

	/**
	 * Group by Post.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PostGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends PostGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: PostGroupByArgs["orderBy"] }
			: { orderBy?: PostGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, PostGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetPostGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Post model
	 */
	readonly fields: PostFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Post.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PostClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	comments<T extends Prisma.Post$commentsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Post$commentsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$CommentPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	likes<T extends Prisma.Post$likesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Post$likesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$LikePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	linkedNotifications<
		T extends Prisma.Post$linkedNotificationsArgs<ExtArgs> = {},
	>(
		args?: Prisma.Subset<T, Prisma.Post$linkedNotificationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$NotificationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	attachments<T extends Prisma.Post$attachmentsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Post$attachmentsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$MediaPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	bookmarks<T extends Prisma.Post$bookmarksArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Post$bookmarksArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$BookmarkPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	views<T extends Prisma.Post$viewsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Post$viewsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$ContentViewPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Post model
 */
export interface PostFieldRefs {
	readonly id: Prisma.FieldRef<"Post", "String">;
	readonly content: Prisma.FieldRef<"Post", "String">;
	readonly createdAt: Prisma.FieldRef<"Post", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"Post", "DateTime">;
	readonly userId: Prisma.FieldRef<"Post", "String">;
}

// Custom InputTypes
/**
 * Post findUnique
 */
export type PostFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter, which Post to fetch.
	 */
	where: Prisma.PostWhereUniqueInput;
};

/**
 * Post findUniqueOrThrow
 */
export type PostFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter, which Post to fetch.
	 */
	where: Prisma.PostWhereUniqueInput;
};

/**
 * Post findFirst
 */
export type PostFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter, which Post to fetch.
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Posts to fetch.
	 */
	orderBy?:
		| Prisma.PostOrderByWithRelationInput
		| Prisma.PostOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Posts.
	 */
	cursor?: Prisma.PostWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Posts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Posts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Posts.
	 */
	distinct?: Prisma.PostScalarFieldEnum | Prisma.PostScalarFieldEnum[];
};

/**
 * Post findFirstOrThrow
 */
export type PostFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter, which Post to fetch.
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Posts to fetch.
	 */
	orderBy?:
		| Prisma.PostOrderByWithRelationInput
		| Prisma.PostOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Posts.
	 */
	cursor?: Prisma.PostWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Posts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Posts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Posts.
	 */
	distinct?: Prisma.PostScalarFieldEnum | Prisma.PostScalarFieldEnum[];
};

/**
 * Post findMany
 */
export type PostFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter, which Posts to fetch.
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Posts to fetch.
	 */
	orderBy?:
		| Prisma.PostOrderByWithRelationInput
		| Prisma.PostOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Posts.
	 */
	cursor?: Prisma.PostWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Posts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Posts.
	 */
	skip?: number;
	distinct?: Prisma.PostScalarFieldEnum | Prisma.PostScalarFieldEnum[];
};

/**
 * Post create
 */
export type PostCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Post.
	 */
	data: Prisma.XOR<Prisma.PostCreateInput, Prisma.PostUncheckedCreateInput>;
};

/**
 * Post createMany
 */
export type PostCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Posts.
	 */
	data: Prisma.PostCreateManyInput | Prisma.PostCreateManyInput[];
};

/**
 * Post update
 */
export type PostUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Post.
	 */
	data: Prisma.XOR<Prisma.PostUpdateInput, Prisma.PostUncheckedUpdateInput>;
	/**
	 * Choose, which Post to update.
	 */
	where: Prisma.PostWhereUniqueInput;
};

/**
 * Post updateMany
 */
export type PostUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Posts.
	 */
	data: Prisma.XOR<
		Prisma.PostUpdateManyMutationInput,
		Prisma.PostUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Posts to update
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * Limit how many Posts to update.
	 */
	limit?: number;
};

/**
 * Post upsert
 */
export type PostUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Post to update in case it exists.
	 */
	where: Prisma.PostWhereUniqueInput;
	/**
	 * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
	 */
	create: Prisma.XOR<Prisma.PostCreateInput, Prisma.PostUncheckedCreateInput>;
	/**
	 * In case the Post was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.PostUpdateInput, Prisma.PostUncheckedUpdateInput>;
};

/**
 * Post delete
 */
export type PostDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
	/**
	 * Filter which Post to delete.
	 */
	where: Prisma.PostWhereUniqueInput;
};

/**
 * Post deleteMany
 */
export type PostDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Posts to delete
	 */
	where?: Prisma.PostWhereInput;
	/**
	 * Limit how many Posts to delete.
	 */
	limit?: number;
};

/**
 * Post findRaw
 */
export type PostFindRawArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
	 */
	filter?: runtime.InputJsonValue;
	/**
	 * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
	 */
	options?: runtime.InputJsonValue;
};

/**
 * Post aggregateRaw
 */
export type PostAggregateRawArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
	 */
	pipeline?: runtime.InputJsonValue[];
	/**
	 * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
	 */
	options?: runtime.InputJsonValue;
};

/**
 * Post.comments
 */
export type Post$commentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Comment
	 */
	select?: Prisma.CommentSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Comment
	 */
	omit?: Prisma.CommentOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CommentInclude<ExtArgs> | null;
	where?: Prisma.CommentWhereInput;
	orderBy?:
		| Prisma.CommentOrderByWithRelationInput
		| Prisma.CommentOrderByWithRelationInput[];
	cursor?: Prisma.CommentWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[];
};

/**
 * Post.likes
 */
export type Post$likesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Like
	 */
	select?: Prisma.LikeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Like
	 */
	omit?: Prisma.LikeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.LikeInclude<ExtArgs> | null;
	where?: Prisma.LikeWhereInput;
	orderBy?:
		| Prisma.LikeOrderByWithRelationInput
		| Prisma.LikeOrderByWithRelationInput[];
	cursor?: Prisma.LikeWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.LikeScalarFieldEnum | Prisma.LikeScalarFieldEnum[];
};

/**
 * Post.linkedNotifications
 */
export type Post$linkedNotificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Notification
	 */
	select?: Prisma.NotificationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Notification
	 */
	omit?: Prisma.NotificationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.NotificationInclude<ExtArgs> | null;
	where?: Prisma.NotificationWhereInput;
	orderBy?:
		| Prisma.NotificationOrderByWithRelationInput
		| Prisma.NotificationOrderByWithRelationInput[];
	cursor?: Prisma.NotificationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.NotificationScalarFieldEnum
		| Prisma.NotificationScalarFieldEnum[];
};

/**
 * Post.attachments
 */
export type Post$attachmentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Media
	 */
	select?: Prisma.MediaSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Media
	 */
	omit?: Prisma.MediaOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.MediaInclude<ExtArgs> | null;
	where?: Prisma.MediaWhereInput;
	orderBy?:
		| Prisma.MediaOrderByWithRelationInput
		| Prisma.MediaOrderByWithRelationInput[];
	cursor?: Prisma.MediaWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.MediaScalarFieldEnum | Prisma.MediaScalarFieldEnum[];
};

/**
 * Post.bookmarks
 */
export type Post$bookmarksArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Bookmark
	 */
	select?: Prisma.BookmarkSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Bookmark
	 */
	omit?: Prisma.BookmarkOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookmarkInclude<ExtArgs> | null;
	where?: Prisma.BookmarkWhereInput;
	orderBy?:
		| Prisma.BookmarkOrderByWithRelationInput
		| Prisma.BookmarkOrderByWithRelationInput[];
	cursor?: Prisma.BookmarkWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.BookmarkScalarFieldEnum | Prisma.BookmarkScalarFieldEnum[];
};

/**
 * Post.views
 */
export type Post$viewsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ContentView
	 */
	select?: Prisma.ContentViewSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ContentView
	 */
	omit?: Prisma.ContentViewOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ContentViewInclude<ExtArgs> | null;
	where?: Prisma.ContentViewWhereInput;
	orderBy?:
		| Prisma.ContentViewOrderByWithRelationInput
		| Prisma.ContentViewOrderByWithRelationInput[];
	cursor?: Prisma.ContentViewWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.ContentViewScalarFieldEnum
		| Prisma.ContentViewScalarFieldEnum[];
};

/**
 * Post without action
 */
export type PostDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Post
	 */
	select?: Prisma.PostSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Post
	 */
	omit?: Prisma.PostOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PostInclude<ExtArgs> | null;
};
